#include "OptixScene.h"
#include "../gsound/gsSoundMesh.h"
#include "../gsound/gsSoundObject.h"
#include <vector>
#include <cstring>
#include <fstream>
#include <string>
#include <iostream>

#ifdef GSOUND_USE_OPTIX

GSOUND_NAMESPACE_START

OptixScene::OptixScene() {
}

OptixScene::~OptixScene() {
    cleanup();
}

// Load embedded PTX string (assumes generated by CMake or separate build step)
// For now, we will assume a file path or a string literal is available.
// In a real build, we'd use bin2c to embed the PTX.
#ifndef OPTIX_KERNEL_PTX_FILE
#define OPTIX_KERNEL_PTX_FILE "kernels.ptx"
#endif

void OptixScene::initPipeline() {
    if (pipeline) return;
    
    // Check if we have valid PTX content or file
    ::std::ifstream file(OPTIX_KERNEL_PTX_FILE);
    if (!file.is_open()) {
        ::std::cerr << "Failed to open PTX file: " << OPTIX_KERNEL_PTX_FILE << ::std::endl;
        return;
    }
    
    createModule();
    createProgramGroups();
    createPipeline();
    buildSBT();
}

void OptixScene::createModule() {
    OptixModuleCompileOptions moduleCompileOptions = {};
    moduleCompileOptions.maxRegisterCount = OPTIX_COMPILE_DEFAULT_MAX_REGISTER_COUNT;
    moduleCompileOptions.optLevel = OPTIX_COMPILE_OPTIMIZATION_DEFAULT;
    moduleCompileOptions.debugLevel = OPTIX_COMPILE_DEBUG_LEVEL_MINIMAL;

    pipelineCompileOptions.usesMotionBlur = false;
    pipelineCompileOptions.traversableGraphFlags = OPTIX_TRAVERSABLE_GRAPH_FLAG_ALLOW_ANY; // Or INSTANCE
    pipelineCompileOptions.numPayloadValues = 2; // t_hit, primitiveId
    pipelineCompileOptions.numAttributeValues = 2; // barycentrics (default)
    pipelineCompileOptions.exceptionFlags = OPTIX_EXCEPTION_FLAG_NONE;
    pipelineCompileOptions.pipelineLaunchParamsVariableName = "params";

    ::std::ifstream file(OPTIX_KERNEL_PTX_FILE);
    ::std::string ptx((::std::istreambuf_iterator<char>(file)),
                      ::std::istreambuf_iterator<char>());

    OPTIX_CHECK(optixModuleCreate(OptixContext::getInstance().getContext(),
                                 &moduleCompileOptions,
                                 &pipelineCompileOptions,
                                 ptx.c_str(),
                                 ptx.size(),
                                 nullptr, nullptr,
                                 &module));
}

void OptixScene::createProgramGroups() {
    // Raygen
    OptixProgramGroupOptions pgOptions = {};
    OptixProgramGroupDesc rgDesc = {};
    rgDesc.kind = OPTIX_PROGRAM_GROUP_KIND_RAYGEN;
    rgDesc.raygen.module = module;
    rgDesc.raygen.entryFunctionName = "__raygen__rg";
    OPTIX_CHECK(optixProgramGroupCreate(OptixContext::getInstance().getContext(), &rgDesc, 1, &pgOptions, nullptr, nullptr, &raygenPG));

    // Miss
    OptixProgramGroupDesc msDesc = {};
    msDesc.kind = OPTIX_PROGRAM_GROUP_KIND_MISS;
    msDesc.miss.module = module;
    msDesc.miss.entryFunctionName = "__miss__ms";
    OPTIX_CHECK(optixProgramGroupCreate(OptixContext::getInstance().getContext(), &msDesc, 1, &pgOptions, nullptr, nullptr, &missPG));

    // Hit Group
    OptixProgramGroupDesc hgDesc = {};
    hgDesc.kind = OPTIX_PROGRAM_GROUP_KIND_HITGROUP;
    hgDesc.hitgroup.moduleCH = module;
    hgDesc.hitgroup.entryFunctionNameCH = "__closesthit__ch";
    // We can add Intersection program for custom primitives, but we use triangles
    OPTIX_CHECK(optixProgramGroupCreate(OptixContext::getInstance().getContext(), &hgDesc, 1, &pgOptions, nullptr, nullptr, &hitgroupPG));
}

void OptixScene::createPipeline() {
    OptixProgramGroup programGroups[] = { raygenPG, missPG, hitgroupPG };

    pipelineLinkOptions.maxTraceDepth = 1;

    OPTIX_CHECK(optixPipelineCreate(OptixContext::getInstance().getContext(), 
                                   &pipelineCompileOptions, 
                                   &pipelineLinkOptions, 
                                   programGroups, 
                                   sizeof(programGroups)/sizeof(programGroups[0]), 
                                   nullptr, nullptr, &pipeline));
    
    // Set a reasonable default stack size
    OPTIX_CHECK(optixPipelineSetStackSize(pipeline, 
                                         2*1024,  // directCallableStackSizeFromTraversal
                                         2*1024,  // directCallableStackSizeFromState 
                                         2*1024,  // continuationStackSize
                                         1));     // maxTraversableGraphDepth
}

void OptixScene::buildSBT() {
    // 1. RayGen Record
    // ...
    // 2. Miss Record
    // ...
    // 3. HitGroup Records (one per mesh/instance/material)
    // ...
    // This connects the specific mesh vertex/index buffers to the shader instance
}

void OptixScene::cleanup() {
    // Cleanup is called during destruction - be forgiving of errors
    // since CUDA context may already be destroyed
    if(pipeline) {
        optixPipelineDestroy(pipeline);
        pipeline = nullptr;
    }
    // destroy program groups...
    if(raygenPG) { optixProgramGroupDestroy(raygenPG); raygenPG = nullptr; }
    if(missPG) { optixProgramGroupDestroy(missPG); missPG = nullptr; }
    if(hitgroupPG) { optixProgramGroupDestroy(hitgroupPG); hitgroupPG = nullptr; }
    if(module) { optixModuleDestroy(module); module = nullptr; }
    
    // Free GPU buffers for each mesh - ignore errors during cleanup
    for(auto& pair : meshGASCache) {
        if(pair.second.d_buffer) cudaFree(pair.second.d_buffer);
        if(pair.second.d_vertices) cudaFree(pair.second.d_vertices);
        if(pair.second.d_indices) cudaFree(pair.second.d_indices);
    }
    meshGASCache.clear();

    if(d_ias_output_buffer) {
        cudaFree(d_ias_output_buffer);
        d_ias_output_buffer = nullptr;
    }
    
    // Free SBT buffers
    if(d_raygenRecords) { cudaFree(d_raygenRecords); d_raygenRecords = nullptr; }
    if(d_missRecords) { cudaFree(d_missRecords); d_missRecords = nullptr; }
    if(d_hitgroupRecords) { cudaFree(d_hitgroupRecords); d_hitgroupRecords = nullptr; }
    
    iasHandle = 0;
}

void OptixScene::build(const SoundScene& scene) {
    OptixContext::getInstance().init();

    // Build GAS for each unique mesh in the scene
    Size objectCount = scene.getObjectCount();
    for(Size i=0; i<objectCount; ++i) {
        const SoundObject* obj = scene.getObject(i);
        if(!obj) continue;
        const SoundMesh* mesh = obj->getMesh();
        if(mesh && meshGASCache.find(mesh) == meshGASCache.end()) {
            buildGAS(mesh);
        }
    }
    
    // Build IAS
    buildIAS(scene);
}

void OptixScene::buildGAS(const SoundMesh* mesh) {
    // 1. Prepare data
    Size numVertices = mesh->getVertexCount();
    Size numTriangles = mesh->getTriangleCount();
    
    ::std::vector<float> vertices(numVertices * 3);
    for(Size i=0; i<numVertices; ++i) {
        const auto& v = mesh->getVertex(i);
        vertices[i*3+0] = v.x;
        vertices[i*3+1] = v.y;
        vertices[i*3+2] = v.z;
    }
    
    ::std::vector<uint32_t> indices(numTriangles * 3);
    for(Size i=0; i<numTriangles; ++i) {
        const auto t = mesh->getTriangle(i);
        indices[i*3+0] = (uint32_t)t.v[0];
        indices[i*3+1] = (uint32_t)t.v[1];
        indices[i*3+2] = (uint32_t)t.v[2];
    }
    
    // 2. Upload to GPU
    void* d_vertices_ptr = nullptr;
    void* d_indices_ptr = nullptr;
    
    CUDA_CHECK(cudaMalloc(&d_vertices_ptr, vertices.size() * sizeof(float)));
    CUDA_CHECK(cudaMemcpy(d_vertices_ptr, vertices.data(), vertices.size() * sizeof(float), cudaMemcpyHostToDevice));
    
    CUDA_CHECK(cudaMalloc(&d_indices_ptr, indices.size() * sizeof(uint32_t)));
    CUDA_CHECK(cudaMemcpy(d_indices_ptr, indices.data(), indices.size() * sizeof(uint32_t), cudaMemcpyHostToDevice));
    
    // 3. OptiX Build Input
    OptixBuildInput buildInput = {};
    buildInput.type = OPTIX_BUILD_INPUT_TYPE_TRIANGLES;
    
    buildInput.triangleArray.vertexFormat = OPTIX_VERTEX_FORMAT_FLOAT3;
    buildInput.triangleArray.vertexStrideInBytes = sizeof(float) * 3;
    buildInput.triangleArray.numVertices = (uint32_t)numVertices;
    buildInput.triangleArray.vertexBuffers = (CUdeviceptr*)&d_vertices_ptr;
    
    buildInput.triangleArray.indexFormat = OPTIX_INDICES_FORMAT_UNSIGNED_INT3;
    buildInput.triangleArray.indexStrideInBytes = sizeof(uint32_t) * 3;
    buildInput.triangleArray.numIndexTriplets = (uint32_t)numTriangles;
    buildInput.triangleArray.indexBuffer = (CUdeviceptr)d_indices_ptr;
    
    uint32_t triangleInputFlags[1] = { OPTIX_GEOMETRY_FLAG_NONE };
    buildInput.triangleArray.flags = triangleInputFlags;
    buildInput.triangleArray.numSbtRecords = 1;
    
    // 4. Accel Build
    OptixAccelBuildOptions accelOptions = {};
    accelOptions.buildFlags = OPTIX_BUILD_FLAG_ALLOW_COMPACTION | OPTIX_BUILD_FLAG_PREFER_FAST_TRACE;
    accelOptions.operation = OPTIX_BUILD_OPERATION_BUILD;
    
    OptixAccelBufferSizes bufferSizes;
    OptixDeviceContext context = OptixContext::getInstance().getContext();
    OPTIX_CHECK(optixAccelComputeMemoryUsage(context, &accelOptions, &buildInput, 1, &bufferSizes));
    
    void* d_temp_buffer = nullptr;
    CUDA_CHECK(cudaMalloc(&d_temp_buffer, bufferSizes.tempSizeInBytes));
    
    void* d_gas_buffer = nullptr;
    CUDA_CHECK(cudaMalloc(&d_gas_buffer, bufferSizes.outputSizeInBytes));
    
    OptixTraversableHandle handle;
    
    OPTIX_CHECK(optixAccelBuild(context, 0, &accelOptions, &buildInput, 1, 
                               (CUdeviceptr)d_temp_buffer, bufferSizes.tempSizeInBytes,
                               (CUdeviceptr)d_gas_buffer, bufferSizes.outputSizeInBytes,
                               &handle, nullptr, 0));
                               
    CUDA_CHECK(cudaFree(d_temp_buffer));
    
    MeshGAS info;
    info.handle = handle;
    info.d_buffer = d_gas_buffer;
    info.d_vertices = d_vertices_ptr;
    info.d_indices = d_indices_ptr;
    info.vertexCount = numVertices;
    info.triangleCount = numTriangles;
    
    meshGASCache[mesh] = info;
}

void OptixScene::buildIAS(const SoundScene& scene) {
    if(d_ias_output_buffer) {
        CUDA_CHECK(cudaFree(d_ias_output_buffer));
        d_ias_output_buffer = nullptr;
    }

    Size numInstances = scene.getObjectCount();
    ::std::vector<OptixInstance> instances(numInstances);
    
    for(Size i=0; i<numInstances; ++i) {
        const SoundObject* obj = scene.getObject(i);
        const SoundMesh* mesh = obj->getMesh();
        
        // Get transform - Transform3D has position, orientation (3x3 matrix), and scale
        const auto& transform = obj->getTransform(); 
        const auto& orient = transform.orientation;
        const auto& pos = transform.position;
        
        // OptiX uses a 3x4 row-major affine transformation matrix
        // [R00 R01 R02 Tx]
        // [R10 R11 R12 Ty]
        // [R20 R21 R22 Tz]
        float matrix[12] = {
            orient.x.x, orient.y.x, orient.z.x, pos.x,
            orient.x.y, orient.y.y, orient.z.y, pos.y,
            orient.x.z, orient.y.z, orient.z.z, pos.z
        };
        
        ::std::memcpy(instances[i].transform, matrix, 12 * sizeof(float));
        instances[i].instanceId = (unsigned int)i;
        instances[i].visibilityMask = 255;
        instances[i].sbtOffset = 0;
        instances[i].flags = OPTIX_INSTANCE_FLAG_NONE;
        instances[i].traversableHandle = meshGASCache[mesh].handle;
    }
    
    void* d_instances = nullptr;
    Size instancesSize = sizeof(OptixInstance) * numInstances;
    CUDA_CHECK(cudaMalloc(&d_instances, instancesSize));
    CUDA_CHECK(cudaMemcpy(d_instances, instances.data(), instancesSize, cudaMemcpyHostToDevice));
    
    OptixBuildInput buildInput = {};
    buildInput.type = OPTIX_BUILD_INPUT_TYPE_INSTANCES;
    buildInput.instanceArray.instances = (CUdeviceptr)d_instances;
    buildInput.instanceArray.numInstances = (uint32_t)numInstances;
    
    OptixAccelBuildOptions accelOptions = {};
    accelOptions.buildFlags = OPTIX_BUILD_FLAG_PREFER_FAST_TRACE;
    accelOptions.operation = OPTIX_BUILD_OPERATION_BUILD;
    
    OptixAccelBufferSizes bufferSizes;
    OptixDeviceContext context = OptixContext::getInstance().getContext();
    OPTIX_CHECK(optixAccelComputeMemoryUsage(context, &accelOptions, &buildInput, 1, &bufferSizes));
    
    void* d_temp_buffer = nullptr;
    CUDA_CHECK(cudaMalloc(&d_temp_buffer, bufferSizes.tempSizeInBytes));
    CUDA_CHECK(cudaMalloc(&d_ias_output_buffer, bufferSizes.outputSizeInBytes));
    
    OPTIX_CHECK(optixAccelBuild(context, 0, &accelOptions, &buildInput, 1,
                               (CUdeviceptr)d_temp_buffer, bufferSizes.tempSizeInBytes,
                               (CUdeviceptr)d_ias_output_buffer, bufferSizes.outputSizeInBytes,
                               &iasHandle, nullptr, 0));
                               
    CUDA_CHECK(cudaFree(d_temp_buffer));
    CUDA_CHECK(cudaFree(d_instances));
}

void* OptixScene::getVertexBuffer(const SoundMesh* mesh) const {
    auto it = meshGASCache.find(mesh);
    if(it != meshGASCache.end()) return it->second.d_vertices;
    return nullptr;
}

void* OptixScene::getIndexBuffer(const SoundMesh* mesh) const {
    auto it = meshGASCache.find(mesh);
    if(it != meshGASCache.end()) return it->second.d_indices;
    return nullptr;
}

GSOUND_NAMESPACE_END

#endif
